# -*- coding: utf-8 -*-
"""DMG_A4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oJgwylh65ypo9veJL5NRVOHYZr5KRAI7
"""

import random

#Function to calculate list of list for all the items

init=[]
initx=[]
def func1(rows,str):
  for l in range(0,len(rows)):
    row=rows[l].split(' ')
    init.append(row[1:])
    row[0]=str
    initx.append(row)



#fetching data of all .txt files

f = open("countries", 'r'); 
rows = f.read().splitlines(); 
f.close();
func1(rows,"countries")

f = open("animals", 'r'); 
rows = f.read().splitlines(); 
f.close();
func1(rows,"animals")

f = open("fruits", 'r'); 
rows = f.read().splitlines(); 
f.close();
func1(rows,"fruits")

f = open("veggies", 'r'); 
rows = f.read().splitlines(); 
f.close();
func1(rows,"veggies")


random.shuffle(init)
random.shuffle(initx)

for i in range(0,len(initx)):
  for j in range(1,len(initx[0])):
    initx[i][j]=float(initx[i][j])


for i in range(0,len(init)):
  for j in range(0,len(init[0])):
    init[i][j]=float(init[i][j])


category=[]

for item in initx:
  temp=item[0]
  flag=False
  for i in range(0,len(category)):
    if category[i]==temp :
      flag=True
  if flag == False:
    category.append(temp)

CATEGORY={}

for i in range(0,len(category)):
  CATEGORY.update({category[i]:0})

print(CATEGORY)

#K means algorithm

import random
import math
from sklearn import *



#EuclideanDistance

def EuclideanDistance(x,y):
  sum=0
  for i in range(0,len(x)):
    sum+= math.pow(float(x[i])-float(y[i]),2)
  return math.sqrt(sum)



#Manhattan distance

def ManhattanDistance(x,y):
  sum=0
  for i in range(0,len(x)):
    sum+=(abs(x[i]-y[i]))
  return sum



#Normalization

def normalize(init):
  init1= preprocessing.normalize(init, norm='l2', axis=1, copy=True, return_norm=False)
  return init1

#Cosine similarity

def cosine_similarity(x,y):
  Mod_X=0
  Mod_Y=0
  Num=0
  for i in range(0,len(x)):
    Num+=x[i]*y[i]
    Mod_X+=math.pow(x[i],2)
    Mod_Y+=math.pow(y[i],2)
  Mod_X=math.sqrt(Mod_X)
  Mod_Y=math.sqrt(Mod_Y)
  similarity=Num/(Mod_X*Mod_Y)
  return similarity


def k_means_init(k):
  initial_mean=random.sample(init, k)
  list_of_clusters = [[] for i in range(k)]
  for x in range(0,k):
    list_of_clusters[x].append(initial_mean[x])
  return(k_means(k,initial_mean,list_of_clusters))

def k_means(k,initial_mean,list_of_clusters):
  while(True):
    
    for item in init:
      index=0
      distance=999999
      for i in range(0,len(initial_mean)):
        temp=EuclideanDistance(item,initial_mean[i])
        if temp < distance:
          distance=temp
          index=i
      if distance !=0:
        list_of_clusters[index].append(item)

     
    updated_mean=[]
     
    
    
    for List in list_of_clusters:
      lof=len(List[0])
    
      length=len(List)
      l=[]
      for i in range(0,lof):
        sum=0
        for j in range(0,length):
          sum+=List[j][i]
        sum/=length
        l.append(sum)
      updated_mean.append(l)      
  
   # print(updated_mean)
   # print(initial_mean)
    
    flag=False
    for i in range(0,len(initial_mean)):
      for j in range(0,len(initial_mean[0])):
        X=round(initial_mean[i][j],6)
        Y=round(updated_mean[i][j],6)
        if X != Y:
          flag= True     

    if flag== True:
      print("Hi")
      initial_mean=updated_mean
      list_of_clusters = [[] for i in range(k)]
      continue
    else:
      print("bye") 
      
      break

  print(list_of_clusters)    
  return list_of_clusters

#Manhattan Distance





def k_means_manhattan(k,initial_mean,list_of_clusters):
  while(True):
    
    for item in init:
      index=0
      distance=999999
      for i in range(0,len(initial_mean)):
        temp=ManhattanDistance(item,initial_mean[i])
        if temp < distance:
          distance=temp
          index=i
      if distance !=0:
        list_of_clusters[index].append(item)

     
    updated_mean=[]
     
    
    
    for List in list_of_clusters:
      lof=len(List[0])
    
      length=len(List)
      l=[]
      for i in range(0,lof):
        sum=0
        for j in range(0,length):
          sum+=List[j][i]
        sum/=length
        l.append(sum)
      updated_mean.append(l)      
  
   # print(updated_mean)
   # print(initial_mean)
    
    flag=False
    for i in range(0,len(initial_mean)):
      for j in range(0,len(initial_mean[0])):
        X=round(initial_mean[i][j],6)
        Y=round(updated_mean[i][j],6)
        if X != Y:
          flag= True     

    if flag== True:
      print("Hi")
      initial_mean=updated_mean
      list_of_clusters = [[] for i in range(k)]
      continue
    else:
      print("bye") 
      
      break

  print(list_of_clusters)    
  return list_of_clusters

#Cosine Similarity

import statistics as st


def k_means_cosine(k,initial_mean,list_of_clusters):
  while(True):
    
    for item in init:
      index=0
      similarity=-9999
      for i in range(0,len(initial_mean)):
        temp=cosine_similarity(item,initial_mean[i])
        if temp > similarity:
          similarity=temp
          index=i
      #if distance !=0:
      list_of_clusters[index].append(item)

     
    updated_mean=[]
     
    
    
    for List in list_of_clusters:
      lof=len(List[0])
    
      length=len(List)
      l=[]
      for i in range(0,lof):
        med=0
        for j in range(0,length):
          p=[]
          p.append(List[j][i])
        med=st.median(p)          
        l.append(med)
      updated_mean.append(l)      
  
   # print(updated_mean)
   # print(initial_mean)
    
    flag=False
    for i in range(0,len(initial_mean)):
      for j in range(0,len(initial_mean[0])):
        X=round(initial_mean[i][j],6)
        Y=round(updated_mean[i][j],6)
        if X != Y:
          flag= True     

    if flag== True:
      print("Hi")
      initial_mean=updated_mean
      list_of_clusters = [[] for i in range(k)]
      continue
    else:
      print("bye") 
      
      break

  print(list_of_clusters)    
  return list_of_clusters

import collections
def evaluate1(k,list_of_clusters,initx):
  count=0
  items_in_clusters = [[] for i in range(k)]
  i=0
  for items in list_of_clusters:
    for item in items:
      for ite in initx:
        item1=ite[1:]
        flag=False
        for j in range(0,len(item1)):
          if item[j]!= item1[j]:
            flag = True
        if flag==False :
          #print("Hi")
          items_in_clusters[i].append(ite[0])
    i+=1 
  print(items_in_clusters)     
  return items_in_clusters

###Precision & Recall
import numpy as np

def graph(D) :
  items_in_clusters=D


  Total= (len(init)*(len(init)-1))/2
  TP_FP=0   #Total Positives
  TP=0
  FP=0
  FN=0
  precision=0
  recall=0
  F_score=0
  Total_Negatives=0

  for i in range (0,len(items_in_clusters)):
    x=len(items_in_clusters[i])
    TP_FP+=(x*(x-1))/2



  for items in items_in_clusters:
    for key in CATEGORY.keys():
      CATEGORY[key]=0
   
    for item in items:
      CATEGORY[item]+=1
    for key in CATEGORY.keys():
      TP+=(CATEGORY[key]*(CATEGORY[key]-1))/2


  print(TP)
  FP=TP_FP-TP
  Total_Negatives=Total-TP_FP
#print(len(init))


  LIST = []
  i=0
  j=0
  for items in items_in_clusters:
    l=[]
    for key in CATEGORY.keys():
      x=0
      for item in items:
        if key==item:
          x+=1
      l.append(x)
    LIST.append(l)

#print(LIST)
#print(items_in_clusters[3])
#print(CATEGORY)
  print(LIST)

  if len(LIST)==1:
    FN=0
  else:
    i=0
    for items in LIST:
      j=0
      for item in items:
        seq=np.array(LIST[i+1:])
        s=np.sum(seq,axis=0)
        FN=FN+ item*s[j]
        #print(s)
        j+=1
  
      if i==(len(LIST)-2):
        break
      else:
        #print(i)
        i+=1


  precision=TP/(TP_FP)
  recall=TP/(TP+FN)
  F_score=2*((precision*recall)/(precision+recall))

  return precision,recall,F_score

#Eucl Distance

import matplotlib.pyplot as plt 

Precision=[]
Recall=[]
F_Score=[]

for i in range(1,11):
  list_of_clusters=k_means_init(i)
  items_in_clusters=evaluate1(i,list_of_clusters,initx)
  precision,recall,F_score=graph(items_in_clusters)
  Precision.append(precision)
  Recall.append(recall)
  F_Score.append(F_score)

print ("Precision:")
print(Precision)
print("Recall")
print(Recall)
print("F_Score")
print(F_Score)


k=[1,2,3,4,5,6,7,8,9,10]
plt.plot(k,Precision, label = "Precision") 
  
plt.plot(k, Recall, label = "Recall") 
plt.plot(k, F_Score, label = "F_Score") 
  
# naming the x axis 
plt.xlabel('K-value') 
plt.ylabel('y-axis') 
  
# show a legend on the plot 
plt.legend() 
  
# function to show the plot 
plt.show()

#ManhattanDistance

import matplotlib.pyplot as plt 

Precision=[]
Recall=[]
F_Score=[]

for i in range(1,11):
  list_of_clusters=k_means_init(i)
  items_in_clusters=evaluate1(i,list_of_clusters,initx)
  precision,recall,F_score=graph(items_in_clusters)
  Precision.append(precision)
  Recall.append(recall)
  F_Score.append(F_score)
print ("Precision:")
print(Precision)
print("Recall")
print(Recall)
print("F_Score")
print(F_Score)


k=[1,2,3,4,5,6,7,8,9,10]
plt.plot(k,Precision, label = "Precision") 
  
plt.plot(k, Recall, label = "Recall") 
plt.plot(k, F_Score, label = "F_Score") 
  
# naming the x axis 
plt.xlabel('K-value') 
plt.ylabel('y-axis') 
  
# show a legend on the plot 
plt.legend() 
  
# function to show the plot 
plt.show()

#Cosine Graph


import matplotlib.pyplot as plt 

Precision=[]
Recall=[]
F_Score=[]

for i in range(1,11):
  list_of_clusters=k_means_init(i)
  items_in_clusters=evaluate1(i,list_of_clusters,initx)
  precision,recall,F_score=graph(items_in_clusters)
  Precision.append(precision)
  Recall.append(recall)
  F_Score.append(F_score)

print ("Precision:")
print(Precision)
print("Recall")
print(Recall)
print("F_Score")
print(F_Score)


k=[1,2,3,4,5,6,7,8,9,10]
plt.plot(k,Precision, label = "Precision") 
  
plt.plot(k, Recall, label = "Recall") 
plt.plot(k, F_Score, label = "F_Score") 
  
# naming the x axis 
plt.xlabel('K-value') 
plt.ylabel('y-axis') 
  
# show a legend on the plot 
plt.legend() 
  
# function to show the plot 
plt.show()

for row in initx:
  if row[0]=='veggies':
    row[0]=0
  if row[0]=='countries':
    row[0]=1
  if row[0]=='fruits':
    row[0]=2
  if row[0]=='animals':
    row[0]=3
  
  
  


initial=normalize(initx)


initial=initial.tolist()


print((initial))

for i in range(0,len(initx)):
  initial[i][0]=initx[i][0]
  initx[i]=initial[i]

for row in initx:
  if row[0]==0:
    row[0]='veggies'
  if row[0]==1:
    row[0]='countries'
  if row[0]==2:
    row[0]='fruits'
  if row[0]==3:
    row[0]='animals'
  

print(initx)

for i in range(0,len(initx)):
  init[i]=initx[i][1:]
  

print(init)

# Normailization


import matplotlib.pyplot as plt 

Precision=[]
Recall=[]
F_Score=[]

for i in range(1,11):
  list_of_clusters=k_means_init(i)
  items_in_clusters=evaluate1(i,list_of_clusters,initx)
  precision,recall,F_score=graph(items_in_clusters)
  Precision.append(precision)
  Recall.append(recall)
  F_Score.append(F_score)

print ("Precision:")
print(Precision)
print("Recall")
print(Recall)
print("F_Score")
print(F_Score)


k=[1,2,3,4,5,6,7,8,9,10]
plt.plot(k,Precision, label = "Precision") 
  
plt.plot(k, Recall, label = "Recall") 
plt.plot(k, F_Score, label = "F_Score") 
  
# naming the x axis 
plt.xlabel('K-value') 
plt.ylabel('y-axis') 
  
# show a legend on the plot 
plt.legend() 
  
# function to show the plot 
plt.show()